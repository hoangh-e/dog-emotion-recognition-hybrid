# -*- coding: utf-8 -*-
"""[Train] Head Classification - Pure34.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VWXOJkZUiuEchpFZNKM3Ow7jgmx4C5Bl
"""

# Updated to use the new pure.py module
# Uncomment lines below if running in Colab
# !pip install torch torchvision albumentations pandas tqdm gdown
# !gdown 1ZAgz5u64i3LDbwMFpBXjzsKt6FrhNGdW --output cropped_dataset_4k_face.zip

import zipfile
import os

zip_path = "/content/cropped_dataset_4k_face.zip"
extract_path = "/content/data"  # n∆°i ch·ª©a d·ªØ li·ªáu sau gi·∫£i n√©n

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# Ki·ªÉm tra k·∫øt qu·∫£
print("File sau khi gi·∫£i n√©n:")
print(os.listdir(extract_path))

from torchvision import transforms
from torch.utils.data import Dataset, DataLoader
import pandas as pd
import os
from PIL import Image

class MyDataset(Dataset):
    def __init__(self, root, labels_csv, transform=None):
        self.root = root
        df = pd.read_csv(labels_csv)
        self.items = df[['filename', 'label']].values

        # T·∫°o √°nh x·∫° label ‚Üí ch·ªâ s·ªë
        unique_labels = sorted(df['label'].unique())
        self.label2index = {name: i for i, name in enumerate(unique_labels)}

        self.transform = transform

    def __len__(self):
        return len(self.items)

    def __getitem__(self, idx):
        fn, label_str = self.items[idx]
        label_idx = self.label2index[label_str]
        img_path = os.path.join(self.root, label_str, fn)
        img = Image.open(img_path).convert('RGB')
        if self.transform:
            img = self.transform(img)
        return img, label_idx



transform = transforms.Compose([
    transforms.RandomResizedCrop(512),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485,0.456,0.406],
                         std=[0.229,0.224,0.225]),
])
dataset = MyDataset('/content/data/cropped_dataset_4k_face/Dog Emotion', '/content/data/cropped_dataset_4k_face/Dog Emotion/labels.csv', transform)
loader = DataLoader(dataset, batch_size=8, shuffle=True, num_workers=2)

# Import from the new pure module
import torch
import torch.nn as nn
from dog_emotion_classification.pure import Pure34, get_pure_model, PureTrainer, get_pure_transforms



import time
import torch
from tqdm import trange, tqdm
import os

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Create Pure34 model instead of ResNet18
num_classes = len(dataset.label2index)
model = get_pure_model('pure34', num_classes=num_classes, input_size=512)
model = model.to(device)

print(f"üèóÔ∏è Created Pure34 model with {num_classes} classes")
print(f"üìä Parameters: {sum(p.numel() for p in model.parameters()):,}")

crit = torch.nn.CrossEntropyLoss()
opt = torch.optim.Adam(model.parameters(), lr=1e-4)
sched = torch.optim.lr_scheduler.StepLR(opt, step_size=10, gamma=0.1)

# (T√πy ch·ªçn) Load model n·∫øu ƒë√£ c√≥ checkpoint
if os.path.exists("checkpoints/best_model.pt"):
    model.load_state_dict(torch.load("checkpoints/best_model.pt"))
    model.eval()
    print("üì¶ Model loaded from checkpoint.")

total_epochs = 30
best_acc = 0.0  # theo d√µi model t·ªët nh·∫•t

# T·∫°o th∆∞ m·ª•c l∆∞u model n·∫øu ch∆∞a c√≥
os.makedirs("checkpoints", exist_ok=True)

for epoch in range(total_epochs):
    model.train()
    start_epoch = time.time()
    total, correct = 0, 0

    for imgs, labels in tqdm(loader, desc=f"Epoch {epoch+1}/{total_epochs}", unit="batch", total=len(loader)):
        imgs, labels = imgs.to(device), labels.to(device)
        opt.zero_grad()
        logits = model(imgs)
        loss = crit(logits, labels)
        loss.backward()
        opt.step()

        pred = logits.argmax(dim=1)
        total += labels.size(0)
        correct += (pred == labels).sum().item()

    # ƒê·ªìng b·ªô GPU v√† ƒëo th·ªùi gian
    if device == 'cuda':
        torch.cuda.synchronize()
    elapsed = time.time() - start_epoch
    eta = elapsed * (total_epochs - (epoch + 1))
    acc = correct / total
    print(f"Epoch {epoch+1}/{total_epochs} done in {elapsed:.1f}s ‚Äì ETA: {eta/60:.1f}m ‚Äì Acc: {acc:.4f} ‚Äì LR: {sched.get_last_lr()[0]:.5f}")

    # L∆∞u model t·ªët nh·∫•t
    if acc > best_acc:
        best_acc = acc
        torch.save(model.state_dict(), "checkpoints/best_model.pt")
        print("‚úÖ Saved new best model.")

    sched.step()

from google.colab import files
files.download("checkpoints/best_model.pt")

import pandas as pd

# ƒê·ªçc CSV
df = pd.read_csv('/content/data/Dog Emotion/labels_filtered.csv')

# ƒê·∫øm s·ªë record (s·ªë d√≤ng)
print(f"S·ªë d√≤ng (record): {len(df)}")





